import { __assign } from "tslib";
import { combine, commonInit, generateUUID, getTimestamp, includes, msToNs, RequestType, ResourceKind, withSnakeCaseKeys, } from '@datadog/browser-core';
import { startRumAssembly } from './assembly';
import { startRumBatch } from './batch';
import { buildEnv } from './buildEnv';
import { startDOMMutationCollection } from './domMutationCollection';
import { LifeCycle, LifeCycleEventType } from './lifeCycle';
import { startLongTaskCollection } from './longTaskCollection';
import { matchRequestTiming } from './matchRequestTiming';
import { startParentContexts } from './parentContexts';
import { startPerformanceCollection } from './performanceCollection';
import { startRequestCollection } from './requestCollection';
import { computePerformanceResourceDetails, computePerformanceResourceDuration, computeResourceKind, computeSize, } from './resourceUtils';
import { startRumSession } from './rumSession';
import { startUserActionCollection } from './userActionCollection';
import { startViewCollection } from './viewCollection';
export var RumEventCategory;
(function (RumEventCategory) {
    RumEventCategory["USER_ACTION"] = "user_action";
    RumEventCategory["ERROR"] = "error";
    RumEventCategory["LONG_TASK"] = "long_task";
    RumEventCategory["VIEW"] = "view";
    RumEventCategory["RESOURCE"] = "resource";
})(RumEventCategory || (RumEventCategory = {}));
export function startRum(userConfiguration, getGlobalContext) {
    var lifeCycle = new LifeCycle();
    var isCollectingError = true;
    var _a = commonInit(userConfiguration, buildEnv, isCollectingError), errorObservable = _a.errorObservable, configuration = _a.configuration, internalMonitoring = _a.internalMonitoring;
    var session = startRumSession(configuration, lifeCycle);
    internalMonitoring.setExternalContextProvider(function () {
        return combine({
            application_id: userConfiguration.applicationId,
        }, parentContexts.findView(), getGlobalContext());
    });
    var parentContexts = startRumEventCollection(userConfiguration.applicationId, location, lifeCycle, configuration, session, getGlobalContext).parentContexts;
    startRequestCollection(lifeCycle, configuration);
    startPerformanceCollection(lifeCycle, configuration);
    startDOMMutationCollection(lifeCycle);
    if (configuration.trackInteractions) {
        startUserActionCollection(lifeCycle);
    }
    errorObservable.subscribe(function (errorMessage) { return lifeCycle.notify(LifeCycleEventType.ERROR_COLLECTED, errorMessage); });
    return {
        getInternalContext: function (startTime) {
            return doGetInternalContext(parentContexts, userConfiguration.applicationId, session, startTime);
        },
        addUserAction: function (action, context) {
            lifeCycle.notify(LifeCycleEventType.CUSTOM_ACTION_COLLECTED, { action: action, context: context });
        },
    };
}
export function doGetInternalContext(parentContexts, applicationId, session, startTime) {
    var viewContext = parentContexts.findView(startTime);
    if (session.isTracked() && viewContext && viewContext.sessionId) {
        return withSnakeCaseKeys(combine({ applicationId: applicationId }, viewContext, parentContexts.findAction(startTime)));
    }
}
export function startRumEventCollection(applicationId, location, lifeCycle, configuration, session, getGlobalContext) {
    var parentContexts = startParentContexts(lifeCycle, session);
    var batch = startRumBatch(configuration, lifeCycle);
    startRumAssembly(applicationId, configuration, lifeCycle, session, parentContexts, getGlobalContext);
    trackRumEvents(lifeCycle, session);
    startLongTaskCollection(lifeCycle);
    startViewCollection(location, lifeCycle);
    return {
        parentContexts: parentContexts,
        stop: function () {
            // prevent batch from previous tests to keep running and send unwanted requests
            // could be replaced by stopping all the component when they will all have a stop method
            batch.stop();
        },
    };
}
export function trackRumEvents(lifeCycle, session) {
    var handler = function (startTime, rawRumEvent, savedGlobalContext, customerContext) {
        return lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, {
            customerContext: customerContext,
            rawRumEvent: rawRumEvent,
            savedGlobalContext: savedGlobalContext,
            startTime: startTime,
        });
    };
    trackView(lifeCycle, handler);
    trackErrors(lifeCycle, handler);
    trackRequests(lifeCycle, session, handler);
    trackPerformanceTiming(lifeCycle, session, handler);
    trackCustomUserAction(lifeCycle, handler);
    trackAutoUserAction(lifeCycle, handler);
}
export function trackView(lifeCycle, handler) {
    lifeCycle.subscribe(LifeCycleEventType.VIEW_UPDATED, function (view) {
        handler(view.startTime, {
            date: getTimestamp(view.startTime),
            duration: msToNs(view.duration),
            evt: {
                category: RumEventCategory.VIEW,
            },
            rum: {
                documentVersion: view.documentVersion,
            },
            view: {
                loadingTime: msToNs(view.loadingTime),
                loadingType: view.loadingType,
                measures: __assign(__assign({}, view.measures), { domComplete: msToNs(view.measures.domComplete), domContentLoaded: msToNs(view.measures.domContentLoaded), domInteractive: msToNs(view.measures.domInteractive), firstContentfulPaint: msToNs(view.measures.firstContentfulPaint), loadEventEnd: msToNs(view.measures.loadEventEnd) }),
            },
        });
    });
}
function trackErrors(lifeCycle, handler) {
    lifeCycle.subscribe(LifeCycleEventType.ERROR_COLLECTED, function (_a) {
        var message = _a.message, startTime = _a.startTime, context = _a.context;
        handler(startTime, __assign({ message: message, date: getTimestamp(startTime), evt: {
                category: RumEventCategory.ERROR,
            } }, context));
    });
}
function trackCustomUserAction(lifeCycle, handler) {
    lifeCycle.subscribe(LifeCycleEventType.CUSTOM_ACTION_COLLECTED, function (_a) {
        var _b = _a.action, name = _b.name, type = _b.type, customerContext = _b.context, startTime = _b.startTime, savedGlobalContext = _a.context;
        handler(startTime, {
            date: getTimestamp(startTime),
            evt: {
                name: name,
                category: RumEventCategory.USER_ACTION,
            },
            userAction: {
                type: type,
            },
        }, savedGlobalContext, customerContext);
    });
}
function trackAutoUserAction(lifeCycle, handler) {
    lifeCycle.subscribe(LifeCycleEventType.AUTO_ACTION_COMPLETED, function (userAction) {
        handler(userAction.startTime, {
            date: getTimestamp(userAction.startTime),
            duration: msToNs(userAction.duration),
            evt: {
                category: RumEventCategory.USER_ACTION,
                name: userAction.name,
            },
            userAction: {
                id: userAction.id,
                measures: userAction.measures,
                type: userAction.type,
            },
        });
    });
}
function trackRequests(lifeCycle, session, handler) {
    lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, function (request) {
        if (!session.isTrackedWithResource()) {
            return;
        }
        var timing = matchRequestTiming(request);
        var kind = request.type === RequestType.XHR ? ResourceKind.XHR : ResourceKind.FETCH;
        var startTime = timing ? timing.startTime : request.startTime;
        var hasBeenTraced = request.traceId && request.spanId;
        handler(startTime, {
            _dd: hasBeenTraced
                ? {
                    spanId: request.spanId.toDecimalString(),
                    traceId: request.traceId.toDecimalString(),
                }
                : undefined,
            date: getTimestamp(startTime),
            duration: timing ? computePerformanceResourceDuration(timing) : msToNs(request.duration),
            evt: {
                category: RumEventCategory.RESOURCE,
            },
            http: {
                method: request.method,
                performance: timing ? computePerformanceResourceDetails(timing) : undefined,
                statusCode: request.status,
                url: request.url,
            },
            network: {
                bytesWritten: timing ? computeSize(timing) : undefined,
            },
            resource: {
                kind: kind,
                id: hasBeenTraced ? generateUUID() : undefined,
            },
        });
        lifeCycle.notify(LifeCycleEventType.RESOURCE_ADDED_TO_BATCH);
    });
}
function trackPerformanceTiming(lifeCycle, session, handler) {
    lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'resource') {
            handleResourceEntry(lifeCycle, session, handler, entry);
        }
    });
}
export function handleResourceEntry(lifeCycle, session, handler, entry) {
    if (!session.isTrackedWithResource()) {
        return;
    }
    var resourceKind = computeResourceKind(entry);
    if (includes([ResourceKind.XHR, ResourceKind.FETCH], resourceKind)) {
        return;
    }
    handler(entry.startTime, {
        _dd: entry.traceId
            ? {
                traceId: entry.traceId,
            }
            : undefined,
        date: getTimestamp(entry.startTime),
        duration: computePerformanceResourceDuration(entry),
        evt: {
            category: RumEventCategory.RESOURCE,
        },
        http: {
            performance: computePerformanceResourceDetails(entry),
            url: entry.name,
        },
        network: {
            bytesWritten: computeSize(entry),
        },
        resource: {
            kind: resourceKind,
        },
    });
    lifeCycle.notify(LifeCycleEventType.RESOURCE_ADDED_TO_BATCH);
}
//# sourceMappingURL=rum.js.map