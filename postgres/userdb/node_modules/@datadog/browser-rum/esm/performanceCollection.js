import { __assign } from "tslib";
import { DOM_EVENT, getRelativeTime, isNumber, monitor } from '@datadog/browser-core';
import { getDocumentTraceId } from './getDocumentTraceId';
import { LifeCycleEventType } from './lifeCycle';
import { FAKE_INITIAL_DOCUMENT, isAllowedRequestUrl } from './resourceUtils';
function supportPerformanceObject() {
    return window.performance !== undefined && 'getEntries' in performance;
}
function supportPerformanceNavigationTimingEvent() {
    return (window.PerformanceObserver &&
        PerformanceObserver.supportedEntryTypes !== undefined &&
        PerformanceObserver.supportedEntryTypes.includes('navigation'));
}
export function startPerformanceCollection(lifeCycle, configuration) {
    retrieveInitialDocumentResourceTiming(function (timing) {
        handleRumPerformanceEntry(lifeCycle, configuration, timing);
    });
    if (supportPerformanceObject()) {
        handlePerformanceEntries(lifeCycle, configuration, performance.getEntries());
    }
    if (window.PerformanceObserver) {
        var observer = new PerformanceObserver(monitor(function (entries) { return handlePerformanceEntries(lifeCycle, configuration, entries.getEntries()); }));
        var entryTypes = ['resource', 'navigation', 'longtask'];
        // cf https://github.com/w3c/paint-timing/issues/40
        if (document.visibilityState === 'visible') {
            entryTypes.push('paint');
        }
        observer.observe({ entryTypes: entryTypes });
        if (supportPerformanceObject() && 'addEventListener' in performance) {
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377
            performance.addEventListener('resourcetimingbufferfull', function () {
                performance.clearResourceTimings();
            });
        }
    }
    if (!supportPerformanceNavigationTimingEvent()) {
        retrieveNavigationTiming(function (timing) {
            handleRumPerformanceEntry(lifeCycle, configuration, timing);
        });
    }
}
export function retrieveInitialDocumentResourceTiming(callback) {
    runOnReadyState('interactive', function () {
        var timing;
        var forcedAttributes = {
            entryType: 'resource',
            initiatorType: FAKE_INITIAL_DOCUMENT,
            traceId: getDocumentTraceId(document),
        };
        if (supportPerformanceNavigationTimingEvent() && performance.getEntriesByType('navigation').length > 0) {
            var navigationEntry = performance.getEntriesByType('navigation')[0];
            timing = __assign(__assign({}, navigationEntry.toJSON()), forcedAttributes);
        }
        else {
            var relativePerformanceTiming = computeRelativePerformanceTiming();
            timing = __assign(__assign(__assign({}, relativePerformanceTiming), { decodedBodySize: 0, duration: relativePerformanceTiming.responseEnd, name: window.location.href, startTime: 0 }), forcedAttributes);
        }
        callback(timing);
    });
}
function retrieveNavigationTiming(callback) {
    function sendFakeTiming() {
        callback(__assign(__assign({}, computeRelativePerformanceTiming()), { entryType: 'navigation' }));
    }
    runOnReadyState('complete', function () {
        // Send it a bit after the actual load event, so the "loadEventEnd" timing is accurate
        setTimeout(monitor(sendFakeTiming));
    });
}
function runOnReadyState(expectedReadyState, callback) {
    if (document.readyState === expectedReadyState || document.readyState === 'complete') {
        callback();
    }
    else {
        var eventName_1 = expectedReadyState === 'complete' ? DOM_EVENT.LOAD : DOM_EVENT.DOM_CONTENT_LOADED;
        var listener_1 = monitor(function () {
            window.removeEventListener(eventName_1, listener_1);
            callback();
        });
        window.addEventListener(eventName_1, listener_1);
    }
}
function computeRelativePerformanceTiming() {
    var result = {};
    var timing = performance.timing;
    for (var key in timing) {
        if (isNumber(timing[key])) {
            result[key] = timing[key] === 0 ? 0 : getRelativeTime(timing[key]);
        }
    }
    return result;
}
function handlePerformanceEntries(lifeCycle, configuration, entries) {
    entries.forEach(function (entry) {
        if (entry.entryType === 'resource' ||
            entry.entryType === 'navigation' ||
            entry.entryType === 'paint' ||
            entry.entryType === 'longtask') {
            handleRumPerformanceEntry(lifeCycle, configuration, entry);
        }
    });
}
function handleRumPerformanceEntry(lifeCycle, configuration, entry) {
    if (isIncompleteNavigation(entry) || isForbiddenResource(configuration, entry)) {
        return;
    }
    lifeCycle.notify(LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, entry);
}
function isIncompleteNavigation(entry) {
    return entry.entryType === 'navigation' && entry.loadEventEnd <= 0;
}
function isForbiddenResource(configuration, entry) {
    return entry.entryType === 'resource' && !isAllowedRequestUrl(configuration, entry.name);
}
//# sourceMappingURL=performanceCollection.js.map