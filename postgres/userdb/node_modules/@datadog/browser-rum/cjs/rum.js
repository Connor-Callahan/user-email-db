"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var browser_core_1 = require("@datadog/browser-core");
var assembly_1 = require("./assembly");
var batch_1 = require("./batch");
var buildEnv_1 = require("./buildEnv");
var domMutationCollection_1 = require("./domMutationCollection");
var lifeCycle_1 = require("./lifeCycle");
var longTaskCollection_1 = require("./longTaskCollection");
var matchRequestTiming_1 = require("./matchRequestTiming");
var parentContexts_1 = require("./parentContexts");
var performanceCollection_1 = require("./performanceCollection");
var requestCollection_1 = require("./requestCollection");
var resourceUtils_1 = require("./resourceUtils");
var rumSession_1 = require("./rumSession");
var userActionCollection_1 = require("./userActionCollection");
var viewCollection_1 = require("./viewCollection");
var RumEventCategory;
(function (RumEventCategory) {
    RumEventCategory["USER_ACTION"] = "user_action";
    RumEventCategory["ERROR"] = "error";
    RumEventCategory["LONG_TASK"] = "long_task";
    RumEventCategory["VIEW"] = "view";
    RumEventCategory["RESOURCE"] = "resource";
})(RumEventCategory = exports.RumEventCategory || (exports.RumEventCategory = {}));
function startRum(userConfiguration, getGlobalContext) {
    var lifeCycle = new lifeCycle_1.LifeCycle();
    var isCollectingError = true;
    var _a = browser_core_1.commonInit(userConfiguration, buildEnv_1.buildEnv, isCollectingError), errorObservable = _a.errorObservable, configuration = _a.configuration, internalMonitoring = _a.internalMonitoring;
    var session = rumSession_1.startRumSession(configuration, lifeCycle);
    internalMonitoring.setExternalContextProvider(function () {
        return browser_core_1.combine({
            application_id: userConfiguration.applicationId,
        }, parentContexts.findView(), getGlobalContext());
    });
    var parentContexts = startRumEventCollection(userConfiguration.applicationId, location, lifeCycle, configuration, session, getGlobalContext).parentContexts;
    requestCollection_1.startRequestCollection(lifeCycle, configuration);
    performanceCollection_1.startPerformanceCollection(lifeCycle, configuration);
    domMutationCollection_1.startDOMMutationCollection(lifeCycle);
    if (configuration.trackInteractions) {
        userActionCollection_1.startUserActionCollection(lifeCycle);
    }
    errorObservable.subscribe(function (errorMessage) { return lifeCycle.notify(lifeCycle_1.LifeCycleEventType.ERROR_COLLECTED, errorMessage); });
    return {
        getInternalContext: function (startTime) {
            return doGetInternalContext(parentContexts, userConfiguration.applicationId, session, startTime);
        },
        addUserAction: function (action, context) {
            lifeCycle.notify(lifeCycle_1.LifeCycleEventType.CUSTOM_ACTION_COLLECTED, { action: action, context: context });
        },
    };
}
exports.startRum = startRum;
function doGetInternalContext(parentContexts, applicationId, session, startTime) {
    var viewContext = parentContexts.findView(startTime);
    if (session.isTracked() && viewContext && viewContext.sessionId) {
        return browser_core_1.withSnakeCaseKeys(browser_core_1.combine({ applicationId: applicationId }, viewContext, parentContexts.findAction(startTime)));
    }
}
exports.doGetInternalContext = doGetInternalContext;
function startRumEventCollection(applicationId, location, lifeCycle, configuration, session, getGlobalContext) {
    var parentContexts = parentContexts_1.startParentContexts(lifeCycle, session);
    var batch = batch_1.startRumBatch(configuration, lifeCycle);
    assembly_1.startRumAssembly(applicationId, configuration, lifeCycle, session, parentContexts, getGlobalContext);
    trackRumEvents(lifeCycle, session);
    longTaskCollection_1.startLongTaskCollection(lifeCycle);
    viewCollection_1.startViewCollection(location, lifeCycle);
    return {
        parentContexts: parentContexts,
        stop: function () {
            // prevent batch from previous tests to keep running and send unwanted requests
            // could be replaced by stopping all the component when they will all have a stop method
            batch.stop();
        },
    };
}
exports.startRumEventCollection = startRumEventCollection;
function trackRumEvents(lifeCycle, session) {
    var handler = function (startTime, rawRumEvent, savedGlobalContext, customerContext) {
        return lifeCycle.notify(lifeCycle_1.LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, {
            customerContext: customerContext,
            rawRumEvent: rawRumEvent,
            savedGlobalContext: savedGlobalContext,
            startTime: startTime,
        });
    };
    trackView(lifeCycle, handler);
    trackErrors(lifeCycle, handler);
    trackRequests(lifeCycle, session, handler);
    trackPerformanceTiming(lifeCycle, session, handler);
    trackCustomUserAction(lifeCycle, handler);
    trackAutoUserAction(lifeCycle, handler);
}
exports.trackRumEvents = trackRumEvents;
function trackView(lifeCycle, handler) {
    lifeCycle.subscribe(lifeCycle_1.LifeCycleEventType.VIEW_UPDATED, function (view) {
        handler(view.startTime, {
            date: browser_core_1.getTimestamp(view.startTime),
            duration: browser_core_1.msToNs(view.duration),
            evt: {
                category: RumEventCategory.VIEW,
            },
            rum: {
                documentVersion: view.documentVersion,
            },
            view: {
                loadingTime: browser_core_1.msToNs(view.loadingTime),
                loadingType: view.loadingType,
                measures: tslib_1.__assign(tslib_1.__assign({}, view.measures), { domComplete: browser_core_1.msToNs(view.measures.domComplete), domContentLoaded: browser_core_1.msToNs(view.measures.domContentLoaded), domInteractive: browser_core_1.msToNs(view.measures.domInteractive), firstContentfulPaint: browser_core_1.msToNs(view.measures.firstContentfulPaint), loadEventEnd: browser_core_1.msToNs(view.measures.loadEventEnd) }),
            },
        });
    });
}
exports.trackView = trackView;
function trackErrors(lifeCycle, handler) {
    lifeCycle.subscribe(lifeCycle_1.LifeCycleEventType.ERROR_COLLECTED, function (_a) {
        var message = _a.message, startTime = _a.startTime, context = _a.context;
        handler(startTime, tslib_1.__assign({ message: message, date: browser_core_1.getTimestamp(startTime), evt: {
                category: RumEventCategory.ERROR,
            } }, context));
    });
}
function trackCustomUserAction(lifeCycle, handler) {
    lifeCycle.subscribe(lifeCycle_1.LifeCycleEventType.CUSTOM_ACTION_COLLECTED, function (_a) {
        var _b = _a.action, name = _b.name, type = _b.type, customerContext = _b.context, startTime = _b.startTime, savedGlobalContext = _a.context;
        handler(startTime, {
            date: browser_core_1.getTimestamp(startTime),
            evt: {
                name: name,
                category: RumEventCategory.USER_ACTION,
            },
            userAction: {
                type: type,
            },
        }, savedGlobalContext, customerContext);
    });
}
function trackAutoUserAction(lifeCycle, handler) {
    lifeCycle.subscribe(lifeCycle_1.LifeCycleEventType.AUTO_ACTION_COMPLETED, function (userAction) {
        handler(userAction.startTime, {
            date: browser_core_1.getTimestamp(userAction.startTime),
            duration: browser_core_1.msToNs(userAction.duration),
            evt: {
                category: RumEventCategory.USER_ACTION,
                name: userAction.name,
            },
            userAction: {
                id: userAction.id,
                measures: userAction.measures,
                type: userAction.type,
            },
        });
    });
}
function trackRequests(lifeCycle, session, handler) {
    lifeCycle.subscribe(lifeCycle_1.LifeCycleEventType.REQUEST_COMPLETED, function (request) {
        if (!session.isTrackedWithResource()) {
            return;
        }
        var timing = matchRequestTiming_1.matchRequestTiming(request);
        var kind = request.type === browser_core_1.RequestType.XHR ? browser_core_1.ResourceKind.XHR : browser_core_1.ResourceKind.FETCH;
        var startTime = timing ? timing.startTime : request.startTime;
        var hasBeenTraced = request.traceId && request.spanId;
        handler(startTime, {
            _dd: hasBeenTraced
                ? {
                    spanId: request.spanId.toDecimalString(),
                    traceId: request.traceId.toDecimalString(),
                }
                : undefined,
            date: browser_core_1.getTimestamp(startTime),
            duration: timing ? resourceUtils_1.computePerformanceResourceDuration(timing) : browser_core_1.msToNs(request.duration),
            evt: {
                category: RumEventCategory.RESOURCE,
            },
            http: {
                method: request.method,
                performance: timing ? resourceUtils_1.computePerformanceResourceDetails(timing) : undefined,
                statusCode: request.status,
                url: request.url,
            },
            network: {
                bytesWritten: timing ? resourceUtils_1.computeSize(timing) : undefined,
            },
            resource: {
                kind: kind,
                id: hasBeenTraced ? browser_core_1.generateUUID() : undefined,
            },
        });
        lifeCycle.notify(lifeCycle_1.LifeCycleEventType.RESOURCE_ADDED_TO_BATCH);
    });
}
function trackPerformanceTiming(lifeCycle, session, handler) {
    lifeCycle.subscribe(lifeCycle_1.LifeCycleEventType.PERFORMANCE_ENTRY_COLLECTED, function (entry) {
        if (entry.entryType === 'resource') {
            handleResourceEntry(lifeCycle, session, handler, entry);
        }
    });
}
function handleResourceEntry(lifeCycle, session, handler, entry) {
    if (!session.isTrackedWithResource()) {
        return;
    }
    var resourceKind = resourceUtils_1.computeResourceKind(entry);
    if (browser_core_1.includes([browser_core_1.ResourceKind.XHR, browser_core_1.ResourceKind.FETCH], resourceKind)) {
        return;
    }
    handler(entry.startTime, {
        _dd: entry.traceId
            ? {
                traceId: entry.traceId,
            }
            : undefined,
        date: browser_core_1.getTimestamp(entry.startTime),
        duration: resourceUtils_1.computePerformanceResourceDuration(entry),
        evt: {
            category: RumEventCategory.RESOURCE,
        },
        http: {
            performance: resourceUtils_1.computePerformanceResourceDetails(entry),
            url: entry.name,
        },
        network: {
            bytesWritten: resourceUtils_1.computeSize(entry),
        },
        resource: {
            kind: resourceKind,
        },
    });
    lifeCycle.notify(lifeCycle_1.LifeCycleEventType.RESOURCE_ADDED_TO_BATCH);
}
exports.handleResourceEntry = handleResourceEntry;
//# sourceMappingURL=rum.js.map